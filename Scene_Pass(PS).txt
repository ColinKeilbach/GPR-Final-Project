#version 400

//This is the Scene Pass Fragment Shader (Pixel Shader)

#ifdef GL_ES
precision highp float; // If GLSL ES is detected, add required precision setting.
#endif // GL_ES

//Helper functions
//x^2
float sq(float x) {
	return x * x;
}

//x^2^2^2^2^2
float sq_5(float x) {
	return sq(sq(sq(sq(sq(x)))));
}

layout (location = 0) out vec4 rtFragColor;

in vec4 vNormal;

in vec4 vLightDirection[3];
in float vIntensity[3];
in vec4 vPosition;
in vec2 vTexcoord;

uniform sampler2D uTex; // represented by 0
uniform sampler2D uNoise; //noise image
uniform float uTime;
uniform vec2 uResolution;

//-------------------------------------------------------------------------------------
//LIGHT CALCULATIONS
void lightCalc(out float diffuseIntensity, out float specularIntensity, in vec4 direction, in float intensity, in vec4 position, in vec4 camera){
	//specularIntensity calculation
	vec4 halfwayVector = normalize(direction - camera);

	float specularCoefficient = max(0.0, dot(vNormal, vec4(halfwayVector.xyz, 0.0)));
	
	specularIntensity = sq_5(sq_5(specularCoefficient)); //focuses the highlight
	
	//diffuseIntensity calculation
	float dist = length(direction);
	
	float diffuseCoefficient = max(0.0, dot(vNormal, direction)); //max stops it from being negative

	float attenuatedIntensity = 1.0 / (1.0 + dist / intensity + sq(dist) / sq(intensity));
	
	diffuseIntensity = diffuseCoefficient * attenuatedIntensity;
}

//NOISE FUNCTION
float noise(in float seed) {
	float normalizedSeed = sin(sq(mod(uTime, 100.0) * seed)); //makes this graph https://www.desmos.com/calculator/wc7okcgjjb
	vec4 noiseCoord = texture(uNoise, vec2(normalizedSeed, -normalizedSeed)); //gets the color from noise.jpg
	
	
	return noiseCoord.r; //returns the red value as a float
}

// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)
//    point: input 3D vector
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)
//    offset: input 3D vector
vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

// calcViewport: calculate the viewing plane (viewport) coordinate
//    viewport:       output viewing plane coordinate
//    ndc:            output normalized device coordinate
//    uv:             output screen-space coordinate
//    aspect:         output aspect ratio of screen
//    resolutionInv:  output reciprocal of resolution
//    viewportHeight: input height of viewing plane
//    fragCoord:      input coordinate of current fragment (in pixels)
//    resolution:     input resolution of screen (in pixels)
void calcViewport(out vec3 viewport, out vec2 ndc, out vec2 uv,
                  out float aspect, out vec2 resolutionInv,
                  in float viewportHeight, in float focalLength,
                  in vec2 fragCoord, in vec2 resolution)
{
    // inverse (reciprocal) resolution = 1 / resolution
    resolutionInv = 1.0 / resolution;
    
    // aspect ratio = screen width / screen height
    aspect = resolution.x * resolutionInv.y;

    // uv = screen-space coordinate = [0, 1) = coord / resolution
    uv = fragCoord * resolutionInv;

    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1
    ndc = uv * 2.0 - 1.0;

    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2), z = -f
    viewport = vec3(ndc * vec2(aspect, 1.0) * (viewportHeight * 0.5), -focalLength);
}

// calcRay: calculate the ray direction and origin for the current pixel
//    rayDirection: output direction of ray from origin
//    rayOrigin:    output origin point of ray
//    viewport:     input viewing plane coordinate (use above function to calculate)
//    focalLength:  input distance to viewing plane
void calcRay(out vec4 rayDirection, out vec4 rayOrigin,
             in vec3 eyePosition, in vec3 viewport)
{
    // ray origin relative to viewer is the origin
    // w = 1 because it represents a point; can ignore when using
    rayOrigin = asPoint(eyePosition);

    // ray direction relative to origin is based on viewing plane coordinate
    // w = 0 because it represents a direction; can ignore when using
    rayDirection = asOffset(viewport - eyePosition);
}

//Returns the length^2 of a vector
float lenSq(vec2 x)
{
    return dot(x, x);
}

float lenSq(vec3 x)
{
    return dot(x, x);
}

//sSphere: Define a sphere and what it entails
//	center: Center of sphere as a point on the screen
//	radius: Radius of the sphere
struct sSphere
{
    vec4 center;
    float radius;
    vec4 color;
};

const int maxSpheres = 100;
int numSpheres;
vec4 sphereColor[maxSpheres];
sSphere spheres[maxSpheres];

//initSphere: Set the values of a sphere object created
//Takes in a sphere object as a structure and sets its center and radius
//according to the values passed into the function
void initSphere(out sSphere sphere, in vec3 center, in float radius, in vec4 color)
{
    sphere.center = asPoint(center);
    sphere.radius = radius;
    sphere.color = color;
    sphereColor[numSpheres] = sphere.color;
    spheres[numSpheres] = sphere;
    numSpheres++;
}

bool hit(in sSphere sphere, in vec4 rayDirection)
{
	vec3 dp;
    dp.xy = rayDirection.xy - sphere.center.xy;
    float lSq = lenSq(dp.xy), 
        rSq = sphere.radius * sphere.radius;
    return lSq <= rSq;
}

// calcColor: calculate the color of a pixel given a ray
//    rayDirection: input ray direction
//    rayOrigin:    input ray origin
vec4 calcColor(in vec4 rayDirection, in vec4 rayOrigin)
{
   
    // DUMMY RESULT: OUTPUT RAY DIRECTION AS-IS
    //  -> what does the ray look like as color?
    //return rayDirection;
    
    // SCENE
    //Declare a sphere and define its components
    sSphere sphere;
    initSphere(sphere, vec3(0.0, 0.5, 0.0), 0.2, vec4(1.0, 0.0, 0.0, 1.0));
    
    sSphere sphereTwo;
    initSphere(sphereTwo, vec3(0.0, -0.5, 0.0), 0.2, vec4(0.0, 1.0, 0.0, 1.0));
	
    bool hitSphere;

    for(int i = 0; i < numSpheres; i++)
    {
    	hitSphere = hit(spheres[i], rayDirection);
    	if(hitSphere)
    	{
			return sphereColor[i];
    	}
    }
	
	// BACKGROUND
	const vec3 warm = vec3(0.8, 0.4, 0.2), cool = vec3(0.2, 0.4, 0.8);
	return vec4(mix(warm, cool, rayDirection.y), 1.0);
}

void main() {
	//Solid Color
	rtFragColor = vec4(1.0, 0.0, 0.0, 1.0);
	//Texture
	vec2 uv = vTexcoord;
	//rtFragColor = texture(uTex, uv);
	
	//Light
	float diffuseIntensity[3], specularIntensity[3];
	lightCalc(diffuseIntensity[0], specularIntensity[0], vLightDirection[0], vIntensity[0], vPosition, vec4(0.0)); //camera is 0,0,0 in view-space
	lightCalc(diffuseIntensity[1], specularIntensity[1], vLightDirection[1], vIntensity[1], vPosition, vec4(0.0));
	lightCalc(diffuseIntensity[2], specularIntensity[2], vLightDirection[2], vIntensity[2], vPosition, vec4(0.0));
	
	rtFragColor = 0.3 * rtFragColor; //0.3 is ambient light
	rtFragColor += (diffuseIntensity[0] * vec4(1.0) + specularIntensity[0] * vec4(1.0));
	rtFragColor += (diffuseIntensity[1] * vec4(1.0) + specularIntensity[1] * vec4(1.0));
	rtFragColor += (diffuseIntensity[2] * vec4(1.0) + specularIntensity[2] * vec4(1.0));
	//go to objects
	//create RT rtScene
	//change Properties for the program
	//change render target to rtScene

// viewing plane (viewport) info
    vec3 viewport;
    vec2 ndc, uv, resolutionInv;
    float aspect;
    const float viewportHeight = 2.0, focalLength = 1.0;

    // ray
    vec4 rayDirection, rayOrigin;

    // setup
    rtFragColor = vec4(0.0);
    
    calcViewport(viewport, ndc, uv, aspect, resolutionInv,
    	             viewportHeight, focalLength,
    	             gl_FragCoord.xy, uResolution);
    calcRay(rayDirection, rayOrigin, vec3(0.0), viewport);
    
    rtFragColor += calcColor(rayDirection, rayOrigin);
}